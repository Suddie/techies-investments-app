
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      // Checks if the authenticated user's ID matches the given userId.
      // Also implies the user is authenticated.
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Function to get the currently authenticated user's accessLevel.
    // This function is based on the one in your screenshot.
    // It performs a 'get' operation.
    function getUserAccessLevel() {
      // This path uses request.auth.uid, so it should only be called
      // when isAuthenticated() is true to ensure request.auth.uid is valid.
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.accessLevel;
    }

    // Function to check if the current user has a specific access level or better (lower number).
    function hasAccessLevel(requiredLevel) {
      // 1. Check if user is authenticated (guards use of request.auth.uid in getUserAccessLevel).
      // 2. Call getUserAccessLevel() to get the stored level.
      // 3. Check if the stored level is not null.
      // 4. Check if the stored level is a number.
      // 5. Check if the stored level is less than or equal to the required level.
      // Each call to getUserAccessLevel() implies a read operation.
      return isAuthenticated() &&
             (getUserAccessLevel() != null) &&
             (getUserAccessLevel() is number) &&
             (getUserAccessLevel() <= requiredLevel);
    }

    function isAdmin() {
      // Admin has accessLevel 1.
      return hasAccessLevel(1);
    }

    // Users Collection
    match /users/{userId} {
      // Allow user to read their own profile, or if the requester is an admin.
      allow read: if isUser(userId) || isAdmin();

      // Allow user to create their own profile document.
      // Ensure the UID in the path matches the authenticated user.
      // Additional checks like matching email can be added.
      allow create: if isUser(userId) && request.resource.data.email == request.auth.token.email;

      // Allow user to update their own profile, or if the requester is an admin.
      // For user self-updates, you might want to restrict which fields can be changed
      // (e.g., prevent user from changing their own 'role' or 'accessLevel').
      allow update: if isAdmin() || (
                      isUser(userId) &&
                      !(request.resource.data.role != resource.data.role) &&
                      !(request.resource.data.accessLevel != resource.data.accessLevel)
                    );
                      // Example: User can update their own data but not role/accessLevel. Admin can update anything.
                      // A more robust way to check for specific field updates:
                      // let disallowedChanges = request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'accessLevel']);
                      // if isUser(userId) && !disallowedChanges || isAdmin();


      // Only admins can delete user documents.
      allow delete: if isAdmin();
    }

    // Global Settings Collection (e.g., /settings/global_settings)
    match /settings/global_settings {
      // Any authenticated user can read the global application settings.
      allow read: if isAuthenticated();

      // Only admins can create, update, or delete the global settings document.
      allow write: if isAdmin();
    }

    // Contributions Collection
    match /contributions/{contributionId} {
      // Authenticated users can create contributions for themselves.
      // Ensure the 'userId' in the new contribution document matches the authenticated user's UID.
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;

      // Users can read their own contributions.
      // Users with admin-level access (level 1) can read any contribution.
      allow read: if hasAccessLevel(1) || (isAuthenticated() && resource.data.userId == request.auth.uid);

      // Only users with admin-level access (level 1) can update or delete contributions.
      // (e.g., for corrections).
      allow update: if hasAccessLevel(1);
      allow delete: if hasAccessLevel(1);
    }

    // Notifications Collection
    match /notifications/{notificationId} {
      // Users can read notifications targeted to their userId or to 'all'.
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || resource.data.userId == 'all');

      // Writing notifications (create, update, delete) is an admin-only operation.
      allow write: if isAdmin();
    }

    // You can add more collection rules here following similar patterns.
    // For example:
    // match /expenses/{expenseId} { ... }
    // match /projects/{projectId} { ... }

  }
}
