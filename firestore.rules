rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuth() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuth() && request.auth.uid == userId;
    }

    // Function to get the access level of the requesting user from their profile
    function getUserAccessLevel() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.accessLevel;
    }

    // Function to check if the user has a specific access level or higher (lower number means higher privileges)
    function hasAccessLevel(level) {
      let userLevel = getUserAccessLevel();
      return isAuth() && userLevel <= level;
    }
    
    function isAdmin() {
      return hasAccessLevel(1) && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'Admin';
    }

    // Users Collection
    match /users/{userId} {
      // Allow user to read their own profile
      allow read: if isUser(userId) || hasAccessLevel(1); // Admins can read any user profile
      // Allow user to update their own profile (e.g. name, tpin, requiresPasswordChange)
      // Restrict role and accessLevel changes to Admins
      allow update: if isUser(userId) && !(request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'accessLevel']))
                      || (hasAccessLevel(1) && request.resource.data.email == resource.data.email); // Admins can update any profile, but not email
      // Allow Admins to create users. For client-side creation, ensure email is verified if needed by your app logic.
      allow create: if hasAccessLevel(1);
      // Generally, don't allow client-side deletion of users. Manage through Admin SDK or Cloud Functions.
      allow delete: if false; // Or if hasAccessLevel(1) if absolutely needed client-side.
    }

    // Settings Collection
    match /settings/global_settings {
      // Allow authenticated users to read global settings (e.g., for appName, currencySymbol)
      allow read: if isAuth();
      // Only allow users with access level 1 (Admins/Treasurers etc.) to write/update settings
      allow write: if hasAccessLevel(1);
    }

    // Contributions Collection
    match /contributions/{contributionId} {
      // Allow users with access level 3 or higher to create their own contributions
      allow create: if hasAccessLevel(3) && request.resource.data.userId == request.auth.uid;
      // Allow users to read their own contributions, or level 2+ to read all
      allow read: if (isAuth() && resource.data.userId == request.auth.uid) || hasAccessLevel(2);
      // Allow users to update their own contributions if certain fields (e.g. notes), or level 1 to update more
      allow update: if (isAuth() && resource.data.userId == request.auth.uid && !(request.resource.data.diff(resource.data).affectedKeys().hasAny(['amount', 'isLate', 'userId']))) 
                      || hasAccessLevel(1);
      // Allow level 1 to delete
      allow delete: if hasAccessLevel(1);

      // Validation for creation:
      // - amount must be a number
      // - monthsCovered must be a list and not empty
      // - userId must match the authenticated user's UID
      // - isLate should not be set by client (system determined)
      // allow create: if request.resource.data.amount is number
      //               && request.resource.data.monthsCovered is list
      //               && request.resource.data.monthsCovered.size() > 0
      //               && request.resource.data.userId == request.auth.uid
      //               && !('isLate' in request.resource.data); 
                       // Consider min/max contribution validation if not handled by Cloud Function
    }

    // Expenses Collection
    match /expenses/{expenseId} {
      // Level 1 can create, update, delete expenses
      allow create, update, delete: if hasAccessLevel(1) && request.resource.data.enteredByUid == request.auth.uid;
      // Level 3 and above can read expenses
      allow read: if hasAccessLevel(3);

      // Validation for expense creation/update (example)
      // Ensure required fields are present and have correct types.
      // allow write: if hasAccessLevel(1)
      //              && request.resource.data.description is string
      //              && request.resource.data.description.size() > 0
      //              && request.resource.data.date is timestamp
      //              && request.resource.data.category is string
      //              && request.resource.data.quantity is number && request.resource.data.quantity > 0
      //              && request.resource.data.unitPrice is number && request.resource.data.unitPrice >= 0
      //              && request.resource.data.totalAmount is number && request.resource.data.totalAmount >= 0
      //              && request.resource.data.enteredByUid == request.auth.uid;
    }
    
    // Placeholder for future collections (e.g., penalties, auditLog, stockItems, milestones, tenants, etc.)
    // match /penalties/{penaltyId} {
    //   allow read, write: if hasAccessLevel(1);
    // }
    //
    // match /auditLog/{logId} {
    //   allow read: if isAuth();
    //   allow write: if false; // Audit logs should ideally be written by backend/Cloud Functions
    // }

  }
}
