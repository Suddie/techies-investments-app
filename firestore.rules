
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      // Ensure this path is correct and $(database) is resolved.
      // This get() operation reads the user document.
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    // IMPORTANT: This function makes a document read.
    // Ensure its usage is optimized in rules to avoid excessive reads.
    function getUserAccessLevel(userId) {
      let userData = getUserData(userId);
      // Check if userData itself is null (document doesn't exist)
      // or if accessLevel field is not present in userData.
      // Default to a highly restrictive level (4) if profile or accessLevel is missing.
      return userData == null || !('accessLevel' in userData) ? 4 : userData.accessLevel;
    }

    function canManageUsers(userId) {
      return isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
    }

    // Users Collection
    match /users/{userId} {
      allow read: if isAuthenticated() && (isUser(userId) || getUserAccessLevel(request.auth.uid) == 1);
      allow create: if canManageUsers(request.auth.uid); // Admin (Level 1) can create users
      allow update: if isAuthenticated() &&
                       (
                         (isUser(userId) && DisallowAdminFieldsChangeForUser()) || // User updating their own, restricted fields
                         getUserAccessLevel(request.auth.uid) == 1 // Admin can update anything
                       );
      allow delete: if getUserAccessLevel(request.auth.uid) == 1; // Only admins can delete users

      // Users cannot change their own role, accessLevel, or status.
      function DisallowAdminFieldsChangeForUser() {
        return !(request.resource.data.keys().hasAny(['role', 'accessLevel', 'status']));
      }
    }

    // Contributions Collection
    match /contributions/{contributionId} {
      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.userId &&
                       getUserAccessLevel(request.auth.uid) <= 3 &&
                       ValidateContributionAmount(request.resource.data.amount);
      allow read: if isAuthenticated() &&
                     (
                       request.auth.uid == resource.data.userId || // User can read their own
                       getUserAccessLevel(request.auth.uid) <= 1 // Level 1 can read all
                     );
      allow update: if getUserAccessLevel(request.auth.uid) <= 1; // L1 can update
      allow delete: if getUserAccessLevel(request.auth.uid) <= 1; // L1 can delete
    }

    // Function to validate contribution amount against global settings
    function ValidateContributionAmount(amount) {
      let settings = get(/databases/$(database)/documents/settings/global_settings).data;
      // Provide default values if settings or specific fields are missing
      let min = settings == null || settings.contributionMin == null ? 0 : settings.contributionMin;
      let max = settings == null || settings.contributionMax == null ? 1000000000 : settings.contributionMax; // A very large number if not set
      return amount >= min && amount <= max;
    }

    // Expenses Collection
    match /expenses/{expenseId} {
      allow create: if isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
      allow read: if isAuthenticated(); // Any authenticated user can read expenses
      allow update: if isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
      allow delete: if isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
    }

    // Settings Collection
    match /settings/global_settings {
      // Admins (Level 1) can read/write global_settings.
      // Non-admins might need read access if settings are used client-side for UI rendering (e.g. appName, currencySymbol)
      // For stricter security, sensitive settings read by client could be exposed via a Cloud Function.
      // For now, assuming Level 1 for write, and broader read if needed (adjust if login page needs settings before auth).
      // Current app design fetches settings after auth, so L1 read is fine.
      allow read: if isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
      allow write: if isAuthenticated() && getUserAccessLevel(request.auth.uid) == 1;
    }

    // Notifications Collection
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid || resource.data.userId == 'all');
      // User can only update the 'isRead' field of their own notifications.
      allow update: if isAuthenticated() &&
                       request.auth.uid == resource.data.userId &&
                       request.resource.data.keys().hasOnly(['isRead']) &&
                       request.resource.data.isRead is bool;
      allow create: if getUserAccessLevel(request.auth.uid) == 1; // L1 can create manual notifications
      allow delete: if getUserAccessLevel(request.auth.uid) == 1;
    }

    // Default deny all other paths that are not explicitly matched
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
